<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>小说阅读器</title>
  <style>
    body {
      font-family: "Microsoft YaHei", sans-serif;
      margin: 0;
      padding: 10px;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      color: #333;
      font-size: 12px;
    }
    .reader-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 15px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    .top-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      align-items: center;
      /* 移除 flex-wrap: wrap */
      white-space: nowrap;
      overflow-x: auto;
      /* 隐藏滚动条但保持功能 */
      scrollbar-width: none; /* Firefox */
    }

    .top-controls::-webkit-scrollbar {
      display: none; /* Chrome/Safari */
    }
    .reader-container:hover .top-controls {
      opacity: 1;
    }
    .control-btn {
      padding: 5px 10px;
      background: transparent;
      color: #333;
      border: 1px solid rgba(0,0,0,0.2);
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
      border-radius: 4px;
    }
    .control-btn:hover { background: rgba(30,144,255,0.08); color:#1E90FF; border-color:#1E90FF; }
    #lineNumberInput {
      width: 70px;
      padding: 4px 8px;
      border: 1px solid rgba(0,0,0,0.2);
      background: transparent;
      color: #333;
      font-size: 11px;
      border-radius: 4px;
    }
    #intervalInput {
      width: 45px;
      padding: 4px 8px;
      border: 1px solid rgba(0,0,0,0.2);
      background: transparent;
      color: #333;
      font-size: 11px;
      border-radius: 4px;
    }
    .auto-flip-label { color:#333; font-size:11px; opacity:0; transition:opacity .3s; display:flex; align-items:center; }
    .reader-container:hover .auto-flip-label { opacity:1; }
    #importNovelBtn {
      padding: 10px 20px;
      background: linear-gradient(45deg,#667eea 0%,#764ba2 100%);
      color: white;
      border: none;
      cursor: pointer;
      font-size: 13px;
      display: block;
      margin: 50px auto;
      border-radius: 20px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      transition: all 0.2s;
    }
    #importNovelBtn:hover { transform: translateY(-2px); box-shadow:0 6px 15px rgba(0,0,0,0.15); }
    #fileInput { display: none; }

    /* 阅读内容区域：保持 pre-wrap，保留换行与空格 */
    .content {
      min-height: 60px;
      line-height: 1.6;
      white-space: pre-wrap; /* 重要：显示文本原始换行 */
      font-size: 13px;
      padding: 20px;
      background: rgba(255,255,255,0.9);
      margin-bottom: 15px;
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 8px;
      transition: all 0.25s ease;
      backdrop-filter: blur(3px);
      overflow: hidden;
      /* ✅ 限制只显示 3 行 */
      max-height: calc(1.6em * 3);
    }
    .status { text-align:center; color:#666; font-size:11px; opacity:0; transition:opacity .3s; }
    .status:hover { opacity: 1; }
  </style>
</head>
<body>
  <div class="reader-container">
    <div class="top-controls">
      <!-- 现在这里是“页/行”输入：若输入 <= 总页数则按页跳，否则按行跳 -->
      <input type="number" id="lineNumberInput" placeholder="页号" min="1" />
      <button class="control-btn" id="goToLineBtn" disabled>跳转</button>
      <button class="control-btn" id="prevBtn" disabled>上一页</button>
      <button class="control-btn" id="nextBtn" disabled>下一页</button>
      <span class="auto-flip-label">自动翻页速度</span>
      <input type="number" id="intervalInput" value="5" min="5" max="300" />
      <button class="control-btn" id="startAutoBtn" disabled>开始自动</button>
      <button class="control-btn" id="stopAutoBtn" disabled>停止自动</button>
    </div>

    <input type="file" id="fileInput" accept=".txt" />
    <button id="importNovelBtn">导入小说</button>

    <div class="content" id="contentArea" style="display:none;">
      请导入TXT格式的小说文件开始阅读
    </div>

    <div class="status" id="statusArea">页: 0/0 | 行: 0</div>
  </div>

  <script>
    class NovelReader {
      constructor() {
        this.content = []; // 原始文本的每一行（按文件中的换行分割）
        this.currentPage = 0; // pages 数组索引
        this.pages = []; // 存储每页起始原始行索引，例如 [0, 5, 12, ...]
        this.maxLinesVisible = 3; // 想要“视觉上”显示的行数（可改）
        this.timerId = null;
        this.fileName = "";

        this.initElements();
        this.bindEvents();
        this.loadProgress();
        // 在 DOMContentLoaded 时可能还没导入文件，所以 pagination 在 import 后运行
      }

      initElements() {
        this.fileInput = document.getElementById('fileInput');
        this.importNovelBtn = document.getElementById('importNovelBtn');
        this.contentArea = document.getElementById('contentArea');
        this.statusArea = document.getElementById('statusArea');
        this.prevBtn = document.getElementById('prevBtn');
        this.nextBtn = document.getElementById('nextBtn');
        this.intervalInput = document.getElementById('intervalInput');
        this.startAutoBtn = document.getElementById('startAutoBtn');
        this.stopAutoBtn = document.getElementById('stopAutoBtn');
        this.lineNumberInput = document.getElementById('lineNumberInput');
        this.goToLineBtn = document.getElementById('goToLineBtn');

        // 离屏容器（用于测量分页），延迟创建
        this.offscreen = null;
      }

      bindEvents() {
        this.importNovelBtn.addEventListener('click', () => this.fileInput.click());
        this.fileInput.addEventListener('change', (e) => {
          if (e.target.files.length > 0) this.importFile();
        });

        this.goToLineBtn.addEventListener('click', () => this.goToLine());
        this.prevBtn.addEventListener('click', () => this.prevPage());
        this.nextBtn.addEventListener('click', () => this.nextPage());
        this.startAutoBtn.addEventListener('click', () => this.startAutoFlip());
        this.stopAutoBtn.addEventListener('click', () => this.stopAutoFlip());

        // 窗口大小改变时需要重新分页（因为换行会改变）
        window.addEventListener('resize', () => {
          if (this.content && this.content.length) {
            // 适当节流：在 resize 连续触发时延迟 200ms 执行
            clearTimeout(this._resizeTimer);
            this._resizeTimer = setTimeout(() => {
              this.paginate();
              // 保证 currentPage 在 bounds 内
              if (this.currentPage >= this.pages.length) this.currentPage = Math.max(0, this.pages.length - 1);
              this.updateDisplay();
            }, 200);
          }
        });
      }

      importFile() {
        const file = this.fileInput.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const text = e.target.result;
            // 更健壮的行分割：支持 \r\n, \r, \n
            this.content = text.split(/\r\n|\r|\n/);
            this.currentPage = 0;
            this.fileName = file.name;

            this.paginate(); // 关键：以视觉行为单位分页
            this.updateDisplay();
            this.saveProgress();
            this.enableControls();

            this.importNovelBtn.style.display = 'none';
            this.contentArea.style.display = 'block';
          } catch (err) {
            this.contentArea.textContent = '文件读取失败';
            this.contentArea.style.display = 'block';
            console.error(err);
          }
        };
        reader.readAsText(file, 'UTF-8');
      }

      // 根据当前样式和 maxLinesVisible，构建离屏容器并划分页表
      paginate() {
        // 清空 pages
        this.pages = [];
        if (!this.content || this.content.length === 0) return;

        // 创建离屏容器（只创建一次）
        if (!this.offscreen) {
          this.offscreen = document.createElement('div');
          document.body.appendChild(this.offscreen);
          Object.assign(this.offscreen.style, {
            position: 'absolute',
            left: '-9999px',
            top: '0',
            visibility: 'hidden',
            whiteSpace: 'pre-wrap',
            overflow: 'visible',
            boxSizing: 'border-box',
            padding: getComputedStyle(this.contentArea).padding,
            fontSize: getComputedStyle(this.contentArea).fontSize,
            fontFamily: getComputedStyle(this.contentArea).fontFamily,
            lineHeight: getComputedStyle(this.contentArea).lineHeight,
            width: `${this.contentArea.clientWidth}px`,
            // ensure same word-wrap behaviour
            wordBreak: getComputedStyle(this.contentArea).wordBreak || 'break-word',
          });
        } else {
          // 更新宽度与样式（resize 时需要）
          this.offscreen.style.width = `${this.contentArea.clientWidth}px`;
          this.offscreen.style.padding = getComputedStyle(this.contentArea).padding;
          this.offscreen.style.fontSize = getComputedStyle(this.contentArea).fontSize;
          this.offscreen.style.fontFamily = getComputedStyle(this.contentArea).fontFamily;
          this.offscreen.style.lineHeight = getComputedStyle(this.contentArea).lineHeight;
        }

        const lineHeight = parseFloat(getComputedStyle(this.contentArea).lineHeight);
        // 如果 line-height 为非数值（例如 "normal"），fallback 为 font-size * 1.2
        const fallbackLineHeight = parseFloat(getComputedStyle(this.contentArea).fontSize || 13) * 1.2;
        const actualLineHeight = isNaN(lineHeight) ? fallbackLineHeight : lineHeight;
        const maxHeight = actualLineHeight * this.maxLinesVisible;

        // 分页：从 0 开始，逐页填充
        let i = 0;
        const n = this.content.length;

        while (i < n) {
          this.offscreen.innerHTML = ''; // 清空
          let j = i;
          let lastGoodJ = i; // 如果第一行本身就超过 maxHeight，也要至少包含一行，避免死循环
          while (j < n) {
            // 用 div 包裹每一原始行（保留换行）
            const lineDiv = document.createElement('div');
            // 为避免 HTML 转义问题，使用 textContent
            lineDiv.textContent = this.content[j];
            this.offscreen.appendChild(lineDiv);

            // 检查高度是否超出
            const h = this.offscreen.scrollHeight;
            if (h > maxHeight) {
              break;
            } else {
              lastGoodJ = j;
              j++;
            }
          }

          // 若第一次就超出（也就是 i==lastGoodJ 且 j==i 且 append 后高度超出），就强制至少占一行
          if (lastGoodJ < i) lastGoodJ = i;

          // 记录这一页的起始行索引 i
          this.pages.push(i);

          // 下页从 lastGoodJ + 1 开始
          i = lastGoodJ + 1;
        }

        // 如果某种场景下没有生成 page（极端），保证至少一页
        if (this.pages.length === 0) this.pages.push(0);
      }

      updateDisplay() {
        if (!this.content || this.content.length === 0) {
          this.contentArea.textContent = '请导入TXT格式的小说文件开始阅读';
          this.statusArea.textContent = '页: 0/0 | 行: 0';
          return;
        }

        // 根据 pages 数组得到当前页的原始行范围
        const startLine = this.pages[this.currentPage];
        const nextPageStart = (this.currentPage + 1 < this.pages.length) ? this.pages[this.currentPage + 1] : this.content.length;
        const pageContent = this.content.slice(startLine, nextPageStart).join('\n');

        // 小淡入效果
        this.contentArea.style.opacity = 0;
        setTimeout(() => {
          this.contentArea.textContent = pageContent;
          this.contentArea.style.opacity = 1;
        }, 100);

        this.statusArea.textContent = `页: ${this.currentPage + 1}/${this.pages.length} | 行: ${this.content.length}`;

        // 输入框显示当前页号（更直观）
        this.lineNumberInput.value = this.currentPage + 1;

        // 按钮状态
        this.prevBtn.disabled = this.currentPage === 0;
        this.nextBtn.disabled = this.currentPage >= this.pages.length - 1;
      }

      totalPages() {
        return this.pages.length;
      }

      prevPage() {
        if (this.currentPage > 0) {
          this.currentPage--;
          this.updateDisplay();
          this.saveProgress();
        }
      }

      nextPage() {
        if (this.currentPage < this.pages.length - 1) {
          this.currentPage++;
          this.updateDisplay();
          this.saveProgress();
        }
      }

      setFlipInterval(seconds) {
        this.autoFlipInterval = Math.max(5, Math.min(300, seconds));
      }

      startAutoFlip() {
        this.stopAutoFlip();
        const val = parseInt(this.intervalInput.value, 10) || 30;
        this.setFlipInterval(val);
        this.timerId = setInterval(() => {
          if (this.currentPage < this.totalPages() - 1) {
            this.nextPage();
          } else {
            this.stopAutoFlip();
          }
        }, this.autoFlipInterval * 1000);

        this.startAutoBtn.disabled = true;
        this.stopAutoBtn.disabled = false;
        this.intervalInput.disabled = true;
      }

      stopAutoFlip() {
        if (this.timerId) {
          clearInterval(this.timerId);
          this.timerId = null;
        }
        this.startAutoBtn.disabled = false;
        this.stopAutoBtn.disabled = true;
        this.intervalInput.disabled = false;
      }

      // 跳转：用户输入如果 <= 页数按页跳，否则按“原始行号”跳到包含该行的页
      goToLine() {
        if (!this.content || this.content.length === 0) return;
        const raw = parseInt(this.lineNumberInput.value, 10);
        if (isNaN(raw) || raw < 1) {
          alert('请输入有效的页号或行号（数字）');
          return;
        }

        if (raw <= this.totalPages()) {
          this.currentPage = raw - 1;
        } else if (raw <= this.content.length) {
          // raw 是原始行号（1-based），找出包含该行的 page
          const targetLineIndex = raw - 1;
          // 找到最大的 p 使得 pages[p] <= targetLineIndex
          let p = this.pages.length - 1;
          for (let i = 0; i < this.pages.length; i++) {
            if (this.pages[i] <= targetLineIndex) p = i; else break;
          }
          this.currentPage = p;
        } else {
          alert('输入超出范围：请输入有效的页号或行号');
          return;
        }

        this.updateDisplay();
        this.saveProgress();
      }

      saveProgress() {
        if (!this.content || this.content.length === 0) return;
        const progress = {
          fileName: this.fileName,
          currentPage: this.currentPage,
          maxLinesVisible: this.maxLinesVisible,
          timestamp: Date.now()
        };
        try {
          localStorage.setItem('novelReaderProgress', JSON.stringify(progress));
        } catch (e) {
          console.warn('保存进度失败', e);
        }
      }

      loadProgress() {
        try {
          const str = localStorage.getItem('novelReaderProgress');
          if (str) {
            const p = JSON.parse(str);
            this.currentPage = p.currentPage || 0;
            this.maxLinesVisible = p.maxLinesVisible || 3;
            // 注意：content 尚未加载，分页将在导入文件后执行
          }
        } catch (e) {
          console.warn('加载进度失败', e);
        }
      }

      enableControls() {
        this.prevBtn.disabled = this.currentPage === 0;
        this.nextBtn.disabled = this.currentPage >= this.totalPages() - 1;
        this.startAutoBtn.disabled = false;
        this.goToLineBtn.disabled = false;
        this.stopAutoBtn.disabled = true;
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      window.novelReader = new NovelReader();
    });
  </script>

</body>
</html>
